{"meta":{"title":"Revincx的小破站","subtitle":"造轮子的地方","description":null,"author":"Revincx","url":"https://blog.revincx.icu","root":"/"},"pages":[{"title":"关于","date":"2020-09-15T04:04:15.000Z","updated":"2021-02-25T10:12:41.387Z","comments":true,"path":"about/index.html","permalink":"https://blog.revincx.icu/about/index.html","excerpt":"","text":"普通双非学校大一学生狗一枚，业余喜欢写写代码，摸摸鱼，也就天天混吃混喝的样子吧(emm)。 技术学过Java，以前开发过一个比较简陋的安卓软件(因为没人用就删库了)，尝试用Java写过爬虫(因为不会Python)，对C语言略微了解(只是了解)。折腾过服务器(脚本复制粘贴)，会一些基本的Linux操作(比如开关机还有ping)。安卓方面喜欢刷机root啥的(日常变砖)，用过Xposed框架(包括Riru)，MIUI钉子户(真香)。网络方面会一点抓包注入啥的(然而连JSON都看不懂)，也折腾过路由器，不过现在基本不玩了。以前学过Photoshop(快忘完了)，用Illustrator做过图标(其实是现学的)，剪辑只接触过一点，基本操作也是都不记得了…. 总结：四个字，啥都不会！ 博客博客是用Github Pages加上Hexo搭建的，主题是ButterFly，换主题后瞬间上档次。本博客上线于2020年暑假，以后会慢慢更新文章的(新建文件夹.jpg)。 联系我 酷安 Github Telegram"},{"title":"标签","date":"2020-11-22T03:03:19.000Z","updated":"2021-02-05T06:32:18.386Z","comments":true,"path":"tags/index.html","permalink":"https://blog.revincx.icu/tags/index.html","excerpt":"","text":"文章标签："},{"title":"友人帐","date":"2021-02-10T13:24:48.000Z","updated":"2021-02-25T10:10:05.290Z","comments":true,"path":"link/index.html","permalink":"https://blog.revincx.icu/link/index.html","excerpt":"","text":""},{"title":"碎碎念(反正应该没人看)","date":"2021-02-09T04:25:34.000Z","updated":"2021-02-24T03:45:09.582Z","comments":true,"path":"words/index.html","permalink":"https://blog.revincx.icu/words/index.html","excerpt":"","text":"记录一下平时的状态，和一些想说的话。 2021年2月10日 立个Flag，凑够10篇文章就接入评论系统。 2021年2月21日 TMD，烦死了 2021年2月24日 要是人不用吃饭就能生活该多好 拾穗 凡事只要以负面的角度思考，不论什么都会变得悲观。然而若是一味地以自己喜欢的方式解释，也可能会看不清四周，在不知不觉间断送生命。就如同把自己关在梦中丧命的国民们一般。 ———《魔女之旅》"}],"posts":[{"title":"学习Vue.js中的render函数","slug":"vue-render-function","date":"2021-02-25T09:33:26.000Z","updated":"2021-02-25T11:23:10.958Z","comments":true,"path":"posts/vue-render-function/","link":"","permalink":"https://blog.revincx.icu/posts/vue-render-function/","excerpt":"","text":"最近在研究Vue.js的内容，感觉render函数理解有些吃力，那就写篇笔记记录一下吧。 Vue.js的工作流程先看一张Vue的工作流程图： 由这张图可以看出：Vue先把现有的template解析成ast(Abstract Syntax Tree - 抽象语法树)，再将抽象语法树编译为render函数，然后把render函数加载到一个虚拟的DOM对象中（其实中间还有进行一系列的复杂操作，这里只是简单解释），最后由虚拟DOM渲染到真实的DOM，也就是界面中。 为什么要使用render函数假设一个原本的Vue实例是这样的： 12345new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; App &#125;, template: &#x27;&lt;App/&gt;&#x27;&#125;) 由于在Vue对象有template属性，并且在template中使用的一个叫App的组件，所以Vue会先把template中的App抽象到语法树中，才能知道有App这个组件，从而去寻找App组件的构造器，以及加载到render函数，渲染等步骤。 对于这个例子，Vue的处理流程是这样的： Template =&gt; AST =&gt; Render =&gt; VirtualDom =&gt; DOM 现在我们把template交给render函数处理： 123456new Vue(&#123; el: &#x27;#app&#x27;, // components: &#123; App &#125;, // template: &#x27;&lt;App/&gt;&#x27; render: h =&gt; h(App)&#125;) 把箭头函数的写法改成ES5原生写法： 12345678new Vue(&#123; el: &#x27;#app&#x27;, // components: &#123; App &#125;, // template: &#x27;&lt;App/&gt;&#x27; render: function (createElement)&#123; return createElement(App) &#125;&#125;) 上面的h对象就是这里的createElement，它是一个函数。Vue默认把它叫做h函数，其中 根据 Vue.js 作者 Even You 的回复，h 的含义如下： It comes from the term “hyperscript”, which is commonly used in many virtual-dom implementations. “Hyperscript” itself stands for “script that generates HTML structures” because HTML is the acronym for “hyper-text markup language”. 它来自单词 hyperscript，这个单词通常用在 virtual-dom 的实现中。Hyperscript 本身是指生成HTML 结构的 script 脚本，因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言） 这样处理之后，Vue的处理流程就变成了： Render =&gt; VirtualDom =&gt; DOM 省去了从Template解析编译到Render的过程，由此以来便节省了内存和依赖。 Vue CLI中render函数的预使用在使用Vue脚手架创建项目时，会有下面的选择： Vue build: Runtime + Compiler: recommended for most users Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specific HTML) are ONLY allowed in .vue files - render functions are required elsewhere 在正式的生产环境中，我们一般会选择第二种runtine-only的方式构建项目，这样就不会为项目安装template的编译器，转而要求开发人员使用render函数进行template的加载，虽然增大了开发难度，但却为项目提高了性能。 createElement函数的详细用法直接创建标签这里createElement函数接收三个参数： 标签名(String)：如h2，p，div 标签的property(Object)：如class属性：{ class: ‘box’ } 标签的Content(Array)：比如一段文本：[ ‘Some Text’ ] 写出来的例子就是这样的： 123456789new Vue(&#123; el: &#x27;#app&#x27;, render: function (createElement)&#123; return createElement(&#x27;h2&#x27;,&#123; class: &#x27;box&#x27; &#125;, [ &#x27;Some Text&#x27; ]) &#125;&#125;) 这就在页面中插入了一个HTML标签： 123&lt;h2 class = &#x27;box&#x27;&gt; Some Text&lt;/h2&gt; 嵌套式写法在原本的内容上再加入一个元素： 123456789new Vue(&#123; el: &#x27;#app&#x27;, render: function (createElement)&#123; return createElement(&#x27;h2&#x27;,&#123; class: &#x27;box&#x27; &#125;, [ &#x27;Some Text&#x27; , createElement(&#x27;button&#x27;,[ &#x27;按钮&#x27; ] )]) &#125;&#125;) 再原本的h2的标签上再加入了一个按钮： 123456&lt;h2 class = &#x27;box&#x27;&gt; Some Text &lt;button&gt; 按钮 &lt;/button&gt;&lt;/h2&gt; 传入组件先创建一个组件对象，然后把组件对象传入改函数： 12345678const cpn = &#123; template: &#x27;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&#x27;, data() &#123; return &#123; message: &#x27;Some Message&#x27; &#125; &#125;&#125; 正如最上面提到的写法，我们在使用下面的代码引入App时，App就已经是一个含render函数的对象。 1import App from &#x27;./App.vue&#x27; 至于原因，是因为我们在使用Webpack时用到了一个Loader，叫做vue-template-compiler，正是这个Loader的存在，使得我们在引入vue文件时，它就已经被转换为了一个可以被render函数使用的对象。","categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.revincx.icu/tags/Vue-js/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.revincx.icu/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"我的个人网盘搭建之路","slug":"my-cloud-storages","date":"2021-02-23T10:14:10.000Z","updated":"2021-02-23T11:37:00.357Z","comments":true,"path":"posts/my-cloud-storages/","link":"","permalink":"https://blog.revincx.icu/posts/my-cloud-storages/","excerpt":"","text":"前一段时间突然心血来潮，想学大佬搞一个个人网盘，正好有一个微软E5的订阅和A1的订阅，于是便开始着手研究网盘站的搭建。 下面我会介绍我尝试过的几个网盘搭建程序并进行对比供大家参考。 OneManager源码地址：OneManager-php Demo：OneManager Heroku Demo 这是一个PHP开发的OneDrive目录索引程序，也是我目前主要在用的一个。 OneManager同样支持云函数搭建，如腾讯，阿里云，百度云，华为云等。我目前将OneManager搭建到了腾讯云函数，响应速度还算可以。 OnePoint源码地址：onepoint Demo：OnePoint Demo 这是一个以Node.js为核心的网盘索引程序。目前支持的网盘有： OneDrive Google Drive coding Teambition node_fs 由于Nodejs的核心，它甚至可以部署在CloudFlare Workers上（虽然CloudFlare的速度感人）。 OnePoint支持文件访问代理，之前一段时间OD的文件下载速度非常玄学，用代理之后会快一点，多线程下载搭配代理使用更佳。不过最近听说OD换了微软Azure的CDN，访问下载速度有可观的改善。 有一点忘了提了，上面两个的网站界面做的都一般，极大降低用户体验(bushi) 不过这两个程序都是可以自己定义界面主题的，虽然开发起来有些麻烦就是了。 而下面的这个界面就比较简洁大方了。 ShareList源码地址：sharelist Demo：无 ShareList同样是Nodejs核心，但是与上面两个相比，Sharelist支持的网盘就比较多，有： Google Drive One Drive 天翼云 和彩云 蓝奏云 本地文件 WebDAV SFTP Teambition Baidu Aliyun Drive 而且Sharelist也支持流量中转，不过没有在线上传文件的功能。但对于展示而言，ShareList的功能已经完全够用了。 不过它也有缺点，由于没有对云函数做专门的适配，目前只能部署在服务器、Heroku、Workers上。 PyOne注意：此项目已停止维护 源码地址：PyOne Demo：无 由于改项目以Python为后端核心，暂时没有合适的服务器部署，而且作者貌似不再维护，但我还是把这个项目贴了出来。因为光看文档就能看出来，这是一个相当强大的网盘程序。文档地址：https://abbeyokgo.github.io/ 不过，这么强大的程序却只支持OneDrive，算是美中不足的一点。 Alist源码地址：alist Demo：Alist Demo 这是一个刚诞生不久的网盘索引程序，以性能出众的Go语言为后端核心，只支持阿里云盘。 虽然只支持阿里云盘，但它任然有很多的可圈可点之处。如：前后端分离、后端逻辑清晰、支持文件上传、加密访问等等。 虽然以Go为核心，但程序的运行方式只有编译好的可执行文件，极大的降低了学习成本。不过可执行文件目前只能运行在服务器上就是了。 但这并不算缺点，由于前后端分离的特性，里可以把前端运行在任何支持Vue.js的Nodejs环境中，比如云函数、Heroku、Vercel（当然服务器也可以），极大的节省了流量开销。 后记由于本人擅长造轮子的性格(bushi)，一直觉得目前的网盘索引程序不是那么完美，既然如此，就想在有生之年开发一个自己的网盘索引程序，打算以Nodejs为核心(毕竟轻量)，希望在有生之年能看到吧~（这不又给自己挖了个新坑）","categories":[],"tags":[{"name":"云储存","slug":"云储存","permalink":"https://blog.revincx.icu/tags/%E4%BA%91%E5%82%A8%E5%AD%98/"},{"name":"网站","slug":"网站","permalink":"https://blog.revincx.icu/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"小程序开发初探及沉浸式界面设计","slug":"wechat-app-dev","date":"2021-02-09T12:06:01.000Z","updated":"2021-02-09T14:17:03.496Z","comments":true,"path":"posts/wechat-app-dev/","link":"","permalink":"https://blog.revincx.icu/posts/wechat-app-dev/","excerpt":"","text":"前一阵子在学习微信小程序开发，于是写一篇文章来记录一下~ （博客文章数喜加一 开发工具值得一提的是微信专门为小程序和网页开发搞了一个IDE，名字毫无特色，就叫微信开发者工具，界面设计的倒还不算反人类，打开工具栏有一个叫调试(调戏)微信开发者工具的选项，才知道这个IDE差不多就是一个加了壳的网页，不过这样做确实方便调试 WMXL语法虽然也算是HTML的变种，但是相对HTML修改了很多部分，比如HTML里的div相当于WXML里的view，img相当于image等等，另外大概超过一半的html元素在wxml里都被阉割，取而代之的是微信自己设计的开箱即用的组件，如scroll-view，swiper等，说实话，开发小程序的难度确实要比网页开发简单多了 MVVM框架微信小程序的模式和目前的主流前端框架都使用了MVVM开发模式，由于之前也没有接触过这个领域，我去查了一下相关的资料。 MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。 在WXML中，使用Mustache语法绑定动态数据，然后在page的js中注册相应的data，如此一来，只要在js中使用this.setData方法操作data的值，页面中绑定的数据就会动态刷新。另外，WXML也支持简单的双向数据绑定。 一开始使用这个模式来编程的时候确实不太习惯，不过后来适应了之后也觉得这种模式确实有优点。再到后来学习了Vue.js之后这种感觉更是明显。 页面的Js逻辑小程序里的Page与安卓里的Activity一样有生命周期。在page加载时，会先调用Page.onLoad()方法作为入口，这一点类似于Activity.onCreate()方法。此外，小程序的生命生命周期中也有着onShow，onReady，onHide，onUnload等回调方法。 沉浸页面开发我个人设计移动端页面的时候喜欢做全沉浸式界面，认为这样的界面简洁，优雅。下面是在为小程序做沉浸式界面时碰到的一些问题和解决方案。 沉浸式状态栏由于我的页面是暗色的，首先要把状态栏调成亮色，然后把navigationBar调成自定义布局。在单page目录下的json文件里添加： 1234&#123; &quot;navigationStyle&quot;: &quot;custom&quot;, &quot;navigationBarTextStyle&quot;: &quot;white&quot;,&#125; 状态栏导航栏适配因为把导航栏改成了自定义，所以我们就得为状态栏和导航栏做单独适配。 首先是获取状态栏的高度，然后再在根布局的上方留一个padding，微信为我们提供了获取状态栏高度的接口： 1var statusHeight = wx.getSystemInfoSync().statusBarHeight 然后就是导航栏了，我们需要自己做一个顶端的导航栏，但是微信并没有提供导航栏高度相关的接口。为了实现效果，最终查到一种方法： 12let menuBtn = wx.getMenuButtonBoundingClientRect()var navHeight = (menuBtn.top - statusHeight) * 2 + menuBtn.height 微信小程序的页面右上方有一个小的菜单按钮，这里获取了按钮实例后，获取了它到屏幕顶端的距离和自身的高度，然后用距离减去状态栏高度再乘以2，最后加上自身的高度，得到的就是标题栏的高度。 实在是妙啊~ 下拉刷新适配由于自定义了顶栏，如果用原先Page上自带的onPullDownRefresh的话效果会十分丑陋，而且会把自定义的标题栏也拉下去。 通过查阅文档得知，scroll-view也有refresher，在WXML里对scroll-view做以下修改： 123456789101112&lt;scroll-view class=&quot;scroll-container&quot; scroll-y=&quot;true&quot; refresher-enabled=&quot;true&quot; refresher-default-style=&quot;white&quot; refresher-threshold=&quot;40&quot; refresher-triggered=&quot;&#123;&#123;refreshTriggered&#125;&#125;&quot; bindrefresherrefresh=&quot;refresh&quot;&gt; ...&lt;/scroll-view&gt; bindrefresherrefresh用来绑定刷新动作对应的方法，而refresher-triggered属性用来绑定当前刷新的状态，正在刷新则为true。 本来还可以自定义下拉刷新控件的样式，但由于默认效果已经足够，而自定义比较麻烦就放弃了这个想法。 底部导航栏因为项目要求开发一个底部导航栏，而用微信提供的方法实现则与沉浸式界面十分的不搭，这里我有造了一波轮子，手动弄了一个导航栏。 底部导航栏的WXML： 12345678&lt;view class=&quot;nav-bar&quot;&gt; &lt;view bindtap=&quot;switchTab&quot; wx:key=&quot;index&quot; wx:for=&quot;&#123;&#123;navbarItem&#125;&#125;&quot; class=&quot;nav-bar-item-container&quot; bindtap=&quot;switchTab&#123;&#123;item.index&#125;&#125;&quot;&gt; &lt;view class=&quot;nav-bar-item&quot;&gt; &lt;text class=&quot;material-icons&quot; style=&quot;color:&#123;&#123;item.color&#125;&#125;&quot;&gt;&#123;&#123;item.icon&#125;&#125;&lt;/text&gt; &lt;text style=&quot;font-size: 12px;color:&#123;&#123;item.color&#125;&#125;&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; WXSS里用的是flex弹性布局，因为代码比较多就不贴出来了，下面主要讲如何实现切换。 我们可以在布局里弄两个container，分别加上wx:if的判断，在js里加一个currentPage的data，导航栏绑定的tap事件是switchTab&#123;&#123;item.index&#125;&#125;然后定义不同的方法，如switchTab1,switchTab2等，来修改currentPage的值。下面是switchTab方法示例： 12345678910111213141516171819switchTab1: function () &#123; var newNavBarItem = this.data.navbarItem var _this = this // 更改图标颜色 newNavBarItem[1].color = &#x27;rgba(255,255,255,0.5)&#x27; newNavBarItem[0].color = &#x27;white&#x27; // 加载页面切换的淡入动画 this.setData(&#123; navbarItem: newNavBarItem, animation2: &#x27;fade-out&#x27;, animation1: &#x27;fade-in&#x27; &#125;) // 动画加载完毕 setTimeout(function () &#123; _this.setData(&#123; currentPage: 1 &#125;) &#125;, 200)&#125; 这样就优雅（个屁）的完成了导航栏的适配，甚至还加入了淡入的动画效果（这个上文没有提，改变class就行了） 后记因为小程序开发的学习只是临时课程，这里我没有对小程序的API进行深层次的研究，所以个别做法可能会与正规的开发规范有一定出入，还请多多指教。","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.revincx.icu/tags/%E7%BC%96%E7%A8%8B/"},{"name":"网页设计","slug":"网页设计","permalink":"https://blog.revincx.icu/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"}]},{"title":"SolidWorks 2020 破解教程","slug":"solidworks-crack","date":"2021-01-22T01:50:14.000Z","updated":"2021-02-23T04:19:37.186Z","comments":true,"path":"posts/solidworks-crack/","link":"","permalink":"https://blog.revincx.icu/posts/solidworks-crack/","excerpt":"","text":"话不多说，直接开始。下载并解压缩后我们会得到下面的文件(夹) SolidWorks.2020.SP3.0.Full.Premium.DVD.iso (主安装文件) SW2020 SP2 fixed SPRs.7z _SolidSQUAD_ (破解补丁) 在_SolidSQUAD_目录下有一个英文版的readme.txt，我们就依照这里的步骤进行安装。 If you already have SW2020 cracked by SSQ installed you can just update existing SW2020 to this one. No additional crack is needed So you can skip steps 1-5 如果你已经安装过了被SSQ破解过的2020版，你可以仅仅升级到此版本并跳过1-5步。 安装前准备断网并准备.NET环境 Before installation, block the outgoing Internet access by means of Windows Firewall or cord plug. Check .NET Framework 3.5 and 4.0 are installed. If .NET Framework 3.5 (including 2.0) is not installed, go to “Control Panel” -&gt; “Programs and Features” -&gt; “Turn Windows features on or off” -&gt; select “.NET Framework 3.5 (including 2.0)” 大概意思就是安装前要断网，然后检查一下有没有安装.NET框架，如果没安装这个框架，去控制面板（从任务栏的搜索框里可以找到）-&gt; 程序和功能 -&gt; 启用或关闭Windows功能里面，把.NET Framework 3.5（.NET 2.0 和 3.0）这一项前面的复选框选中即可（不需要展开）。 添加注册表解压_SolidSQUAD_目录下的SolidSQUAD.7z,双击sw2020_network_serials_licensing.reg并点击确定，将该项添加到注册表。 准备本地Server环境把SolidWorks_Flexnet_Server这个文件夹复制到C盘（其实复制到其他地方也行，只要以后不删掉），右键选择文件夹中的server_install.bat，点击以管理员身份运行。 出现SolidWorks Flexnet Server 服务已经启动成功即可关闭。 开始安装解压SolidWorks.2020.SP3.0.Full.Premium.DVD.iso，打开setup.exe。(其实win10以上也可以直接双击点开，这样会加载成虚拟光驱) 选择 在此计算机上安装，下一步，下一步。 当碰到下面的弹窗时，点击取消。 自行更改安装位置。勾选我接受 SOLIDWORKS 条款 出现如下窗口，确保端口@服务器填的是25734@localhost 安装过程比较耗时间，建议先去吃顿饭或者开一局游戏。 安装完成。 安装后还没完呢，把_SolidSQUAD_\\Program Files\\SOLIDWORKS Corp下的所有文件，复制到你的安装目录。比如你安装在了D盘SolidWorks目录下，那么就把这些文件全部复制到该目录。 双击刚才_SolidSQUAD_目录下的SolidSQUADLoaderEnabler.reg，点击确定。 重启你的电脑。 打开SOLIDWORKS 2020，点击右上角的小问号，点击SolidNetWork License Manager，在弹出的窗口中点击许可顺序选项卡，然后把所有以Premium结尾的项目移动到最上方。点击应用，确定。 破解完成，已经可以联网了。 后记大概分析了一下破解原理，相当于在本地搭建了一个Solidworks许可证的服务器，然后控制SolidWorks从本地的的许可服务器获取许可证。原理很巧妙，但也有不足的一点，本地的运行的服务需要一直挂在后台，虽然占用的内存不多，但确实有点鸡肋。 话说回来，SolidWroks足足占用了我将近20G的空间，而且我甚至感觉开机都变慢了，我在考虑要不还是卸了算了…","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"https://blog.revincx.icu/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"一次腾讯云函数的适配开发","slug":"tencent-scf-dev","date":"2021-01-18T09:34:08.000Z","updated":"2021-01-18T10:10:09.990Z","comments":true,"path":"posts/tencent-scf-dev/","link":"","permalink":"https://blog.revincx.icu/posts/tencent-scf-dev/","excerpt":"","text":"好长时间没有更新博客了，正好前天做了一个自动打卡脚本在腾讯云函数上的适配，中间遇到了一些问题，于是写篇文章来记录一下。 获取用户信息之前的脚本是在Github Actions上定时运行的，获取用户信息的方案是从项目的Secrets中读取。中间其实还有写入到命令行然后再从命令行中读取字符等过程，目的只是保护用户信息不泄露。 命令行： 123python3 main.py &lt;&lt;EOF$&#123;&#123;secrets.USERS&#125;&#125;EOF 读取： 123456789while True: try: users = input() info = users.split(&#x27;,&#x27;) phone.append(info[0]) password.append(info[1]) sckey.append(info[2]) except: break 对于腾讯云函数，我采用的方法是将SCKEY和用户的信息都放入环境变量，这样别人在使用脚本的时候就只需要添加环境变量即可，不用修改代码。 修改之后的读取操作： 12345678910while True: try: user = os.environ.get(&#x27;user&#x27; + str(i)) if user is None: break phone.append(user.split(&#x27;,&#x27;)[0]) password.append(user.split(&#x27;,&#x27;)[1]) i+=1 except: break 添加依赖这是最麻烦的地方，腾讯云函数的运行环境并不是啥依赖都有，查询文档后得知没有的依赖需要和代码包一同打包上传。 在 requirements.txt 中配置依赖信息。 通过 pip install -r requirements.txt -t . 命令安装依赖包。 上传代码库时请将依赖库一同打包上传。 于是尝试把pycrytodome的Cryto模块打包直接上传，结果并不能运行。 查询文档: 函数运行的系统是 CentOS 7，您需要在相同环境下进行安装。若环境不一致，则可能导致上传后运行时出现找不到依赖的错误。您可参考云函数容器镜像进行依赖安装。 看了一下关于容器镜像的文档，好家伙还要用到Docker，但我之前连Docker是干啥的都不知道。。 没办法，硬着头皮下了一个Docker Desktop，升级了下wsl子系统环境（虽然并没有用到wsl2），让后用命令docker pull ccr.ccs.tencentyun.com/scf-repo/runtime-python3:latest拉取容器镜像，把项目文件夹挂载到镜像容器内，然后使用下面的命令安装依赖： pip3 install pipreqspipreqs ./pip install -r requirements.txt -t ./ 其中pipreqs把urllib和requests这两个依赖也放进了requirements.txt，但腾讯云函数的运行环境已经有这两个依赖了，手动去掉即可。 安装完依赖后打包上传，部署并测试，终于能够正常运行了。","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.revincx.icu/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"学校教务系统的漏洞分析","slug":"jiaowu-system-analysis","date":"2020-12-16T03:05:45.000Z","updated":"2021-02-23T04:19:33.853Z","comments":true,"path":"posts/jiaowu-system-analysis/","link":"","permalink":"https://blog.revincx.icu/posts/jiaowu-system-analysis/","excerpt":"","text":"起因本来是想着用Python写一个抢课的脚本，没想到在研究教务系统的网页时发现了我们教务系统漏洞还挺多。 学校教务系统搭建在IIS上，这个方正教务系统用的是ASP .NET,系统版本还是2017年的，据我们学长说以前也被人搞过，但仍然很长一段时间都没有升级系统。 分析这里我已经提前知道了我们选课的那个页面对应xsxk.aspx，但教务系统首页现在的导航栏你活动报名一栏没有开放学生选课的入口，于是我们尝试把地址栏中的xs_main.aspx改为xsxk.aspx。一开始服务器返回了302，页面显示：Object moved to here，没事我们直接点进去，然后会有一个alert弹出，直接忽略就能进去了。 点一下查看课表就可以把隐藏的按钮显示出来。 点选修课程，然后会有一个窗口弹出，这里可能会被chrome拦截，点地址栏的允许弹出窗口就行了。 随便选一个项目，然后点选定，这时主窗口的课程列表就会更新。 随便点一个课程然后又会有一个弹出窗口，同时会有不允许选课的alert弹出。 这时我们不要点确定，否则窗口就会被关闭。复制这个窗口地址栏的网址，新建一个标签页打开。弹出alert后就可以直接点确定，不出意外的话这个标签页应该不会被关闭。 但是这个页面仍然不允许选课，没事，依照刚才的思路，一定是有东西被隐藏了。我们通过开发人员工具可以发现，关闭按钮前面还有两个button的样式都被设为了DISPLAY:NONE。 把这两个button的DISPLAY属性都取消掉，关闭按钮前面就会出现两个空白的按钮。尝试点第一个按钮，就会弹出如下提示。 同时我们想要的选课界面就出来了。 选中单选框并选中不预定教材，然后点点选定按钮提交，就会用保存成功的提示。 我们回到之前的页面查看我们的已选课程： 已选课程里面已经有了我们刚才选的课。 更大胆的想法教务系统网页提交信息时都会同时提交ViewState，虽然没有学过ASP，但通过查询资料，我觉得这个地方大有文章可做。 尝试进行base64解码，结果里面出现了明文，说明没有经过加密。 资料： 当 ASP .NET 中的表单被提交时，表单会随所有表单值一同重新出现。如何做到的呢？这是由于 ASP .NET 维持了您的 ViewState。ViewState 会在页面被提交到服务器时指示其状态。通过在每张页面中的一个 &lt;form runat=&quot;server&quot;&gt;控件中放置一个隐藏域，我们就可以定义页面的状态了。 之后我专门查了关于这个VIEWSTATE里面的猫腻，发现了这个ViewState里面有不少可以利用的漏洞。 其实ViewState 真正的问题在与其潜在的反序列化漏洞风险。ViewState 使用ObjectStateFormatter 进行反序列化，虽然ViewState 采取了加密和签名的安全措施。但是一旦泄露web.config，获取其加密和签名所用的密钥和算法，我们就可以将ObjectStateFormatte 的反序列化payload 进行同样的加密与签名，然后再发给服务器。这样ASP.NET在进行反序列化时，正常解密和校验，然后把payload交给ObjectStateFormatter 进行反序列化，触发其反序列化漏洞，实现RCE。 由此，我们就可以在ViewState里进行XSS注入以实现跨站脚本攻击，从而在服务器上运行任意代码（我是这么理解的）。即使服务端开启了安全验证，我们仍然可以使用其他手段获取签名密钥以实现注入。 不过目前因为知识范围有限，暂时还没有进行相关的实验，以后有机会可以在教务系统上实验一下。 参考资料 .Net 反序列化之 ViewState 利用 如何借助ViewState在ASP.NET中实现反序列化漏洞利用 asp.net 中 viewstate 反序列化攻击 学习记录","categories":[],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://blog.revincx.icu/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Web学习笔记（一）","slug":"web-diary-1","date":"2020-11-21T15:07:06.000Z","updated":"2020-11-22T07:33:16.896Z","comments":true,"path":"posts/web-diary-1/","link":"","permalink":"https://blog.revincx.icu/posts/web-diary-1/","excerpt":"","text":"行内(inline)元素特点： 和其他元素都在一行上 元素的高度、宽度、行高及顶部和底部边距不可设置 元素的宽度就是它包含的文字或图片的宽度，不可改变 举例： a 标签 1&lt;a href=&quot;http://qq.com/&quot;&gt;QQ&lt;/a&gt; 块级(block)元素特点： 每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行） 元素的高度、宽度、行高以及顶和底边距都可设置 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度 举例： p,hn标签 12&lt;p id=&quot;text1&quot;&gt;HTML万岁&lt;/p&gt;&lt;h1 id=&quot;text1&quot;&gt;HTML万岁&lt;/h1&gt; 有序和无序列表有序列表(ol) 有序列表(Ordered List)是一列项目，列表项目使用数字进行标记 12345&lt;ol type=&quot;disc&quot;&gt; &lt;li&gt;MIUI&lt;/li&gt; &lt;li&gt;EMUI&lt;/li&gt; &lt;li&gt;GIAO&lt;/li&gt;&lt;/ol&gt; 无序列表(ul) 无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记 12345&lt;ul type=&quot;disc&quot;&gt; &lt;li&gt;MIUI&lt;/li&gt; &lt;li&gt;EMUI&lt;/li&gt; &lt;li&gt;GIAO&lt;/li&gt;&lt;/ul&gt; 表格 表格由&lt;table&gt;标签来定义。每个表格均有若干行（由 标签定义），每行被分割为若干单元格（由 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 表格示例： 1234567891011121314&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;号码&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Giao&lt;/td&gt; &lt;td&gt;110&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Miao&lt;/td&gt; &lt;td&gt;120&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格样式示例； 1234567table&#123; border: 1px solid; border-collapse: collapse;&#125;th,tr,td&#123; border: 1px solid;&#125; 表格跨行与跨列合并 12345678910111213141516&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;号码&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Giao&lt;/td&gt; &lt;td&gt;110&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;派出所&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;Miao&lt;/td&gt; &lt;!-- &lt;td&gt;120&lt;/td&gt; --&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： 姓名 号码 地址 Giao 110 派出所 Miao Form表单表单用于向服务器传输数据 一个单选框表单示例 1234&lt;form&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;/&gt;&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; value=&quot;female&quot;/&gt;&lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;&lt;/form&gt; 效果如下： 男 女 一个复选框表单示例 12&lt;input type=&quot;checkbox&quot; id=&quot;basketball&quot; name=&quot;hobby&quot;&gt;&lt;label for=&quot;basketball&quot;&gt;篮球&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;football&quot; name=&quot;hobby&quot;&gt;&lt;label for=&quot;football&quot;&gt;足球&lt;/label&gt; 效果如下： 篮球足球 Frame框架Frameset标签与Frame frameset 元素可定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档。在其最简单的应用中，frameset 元素仅仅会规定在框架集中存在多少列或多少行。您必须使用 cols 或 rows 属性。 &lt;frame&gt; 标签定义 frameset 中的一个特定的窗口（框架） 一个Frameset页面示例 1234567&lt;frameset rows=&quot;20%,*&quot; /&gt; &lt;frame src=&quot;top.html&quot; &gt; &lt;frameset cols=&quot;20%,*&quot;&gt; &lt;frame src=&quot;left.html&quot; /&gt; &lt;frame src=&quot;right.html&quot; /&gt; &lt;/frameset&gt;&lt;/frameset&gt; iFrame标签 iframe 元素会创建包含另外一个文档的内联框架（即行内框架） iframe和frame的区别: frame不能脱离frameSet单独使用，iframe可以； frame不能放在body中； 一个展示本博客的iframe示例： 12&lt;iframe width=&quot;100%&quot; height=&quot;500rem&quot; src=&quot;https://blog.revincx.icu/&quot;&gt;&lt;/iframe&gt; 效果如下（开始套娃）： 一个展示天气的iframe示例： 1234&lt;iframe width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; hspace=&quot;0&quot; src=&quot;https://i.tianqi.com/?c=code&amp;a=getcode&amp;id=35&amp;py=zhengzhou&amp;site=34&amp;icon=1&quot;&gt;&lt;/iframe&gt; 效果如下：","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.revincx.icu/tags/%E7%BC%96%E7%A8%8B/"},{"name":"网页设计","slug":"网页设计","permalink":"https://blog.revincx.icu/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"}]},{"title":"博客整活日记","slug":"blog-diary","date":"2020-11-20T09:19:21.000Z","updated":"2021-02-23T12:58:08.138Z","comments":true,"path":"posts/blog-diary/","link":"","permalink":"https://blog.revincx.icu/posts/blog-diary/","excerpt":"","text":"博客更新历史 2020年9月15日 博客正式建立，使用了Github Pages加Hexo框架，主题使用MaterialFlow 2020年11月15日 抛弃慢的一批的Github Pages，博客接入Vercel，访问速度可以感到明显的提升，虽然还是赶不上国内的CDN快，但基本够用了。 2020年11月20日 将主题更换为ButterFly，并参考小康博客做了一些修改，不得不说ButterFly的功能是真的多，现在感觉好看多了。后续应该还会继续美化，并准备接入评论系统，具体怎么搞还没想好。 2021年2月5日 升级了Butterfly主题版本，并添加了一只萌萌哒的看板娘~ (尽 整 些 没 用 的 2021年2月9日 稍微优化了博客加载速度，开启了一部分js脚本的异步加载，开启了网站的PJAX加载功能，目前没有发现什么bug优化教程参见：基于 Butterfly 的 Pjax 适配方案Hexo 博客访问优化日记 2021年2月23日 10篇文章的Flag已达成，接入了Twikoo评论系统。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.revincx.icu/tags/Hexo/"},{"name":"网页设计","slug":"网页设计","permalink":"https://blog.revincx.icu/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"}]},{"title":"宗教答题直接满分的方法","slug":"contest-answer","date":"2020-11-15T10:35:44.000Z","updated":"2021-01-22T01:51:39.933Z","comments":true,"path":"posts/contest-answer/","link":"","permalink":"https://blog.revincx.icu/posts/contest-answer/","excerpt":"","text":"电脑端打开答题页面，然后按F12打开开发者工具，点击上方的Console(或控制台)，粘贴下面的代码，回车。 12345var topicid=topicJsonArray[0][&quot;TOPICID&quot;]; for(var i=0;i&lt;topicJsonArray.length;i++) &#123; topicJsonArray[i][&quot;TOPICID&quot;]=topicid; &#125; 注意会返回一串数字，如果没有就是复制的有问题。&ensp;然后在题库里搜索第一题的答案，把第一题的正确选项选上，直接点提交即可。 手机端下载并安装Via浏览器用这个浏览器打开答题页面，然后点开上方的标题栏，输入下面的代码并回车。 1javascript:var kzt=document.createElement(&quot;script&quot;); kzt.src=&quot;//cdnjs.cloudflare.com/ajax/libs/vConsole/3.3.4/vconsole.min.js&quot;; kzt.onload=function()&#123;new VConsole();&#125;; document.body.appendChild(kzt); 然后界面会多出来一个vConsole按钮，点开，在Console栏下面的Command输入框内输入下面的代码并回车。 12345var topicid=topicJsonArray[0][&quot;TOPICID&quot;]; for(var i=0;i&lt;topicJsonArray.length;i++) &#123; topicJsonArray[i][&quot;TOPICID&quot;]=topicid; &#125; 然后点一下上面的部分返回答题界面，同样是把第一题答对提交即可。 注意复制代码的时候不要把左边的行号复制上。输完代码回车后不要刷新页面，否则需要重新输一次。","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.revincx.icu/tags/%E7%BC%96%E7%A8%8B/"},{"name":"教程","slug":"教程","permalink":"https://blog.revincx.icu/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Easy163添加倒带支持和通知栏快捷设置","slug":"modify-easy163","date":"2020-09-20T04:52:48.000Z","updated":"2021-02-23T04:19:35.602Z","comments":true,"path":"posts/modify-easy163/","link":"","permalink":"https://blog.revincx.icu/posts/modify-easy163/","excerpt":"","text":"&emsp;&emsp;众所周知(屁)，Easy163通过拦截网易云的流量请求，从而实现一些比较NB的效果，比如无版权歌曲下载和付费歌曲下载。可是笔者更喜欢用倒带，而Easy163却不支持倒带，于是决定自己来试试适配倒带。 适配倒带&emsp;&emsp;先在Github仓库搜下网易云的包名，结果如下：吆西，AS启动！ 打开LocalVPNServices.java，定位到如下代码： 1234567891011121314151617if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; try &#123; builder.addAllowedApplication(&quot;com.netease.cloudmusic&quot;); &#125;catch (PackageManager.NameNotFoundException e) &#123; Log.d(TAG, &quot;未检测到网易云音乐&quot;); &#125; try &#123; builder.addAllowedApplication(&quot;com.netease.cloudmusic.lite&quot;); &#125;catch (PackageManager.NameNotFoundException e) &#123; Log.d(TAG, &quot;未检测到网易云音乐极速版&quot;); &#125; &#125; 在这一段结尾加上倒带包名： 12345678try &#123; builder.addAllowedApplication(&quot;com.kuss.rewind&quot;); &#125; catch (PackageManager.NameNotFoundException e) &#123; Log.d(TAG,&quot;未检测到倒带&quot;); &#125; &emsp;&emsp;然后就是对数据包的处理了，这里本来是想着播放列表的请求也要拦截的，最好发现倒带对歌曲播放链接的请求机制和网易云不太一样，于是放弃对Playlist.java的修改，直接修改SongPlayHook.java。之间又发现一个小细节，倒带的请求头host是小写，而网易云请求头Host是大写，就因为这个小细节不知道浪费了我多少时间… 在SongPlayHook.java的请求判断加上下面的代码： 123456789if(host != null) &#123; if(method.equals(&quot;GET&quot;) &amp;&amp; host.endsWith(&quot;music.163.com&quot;) &amp;&amp; path.contains(&quot;/song/enhance/player/url&quot;)) &#123; Log.d(&quot;check rule&quot;,&quot;Rewind&quot;); isRewind = true; return true; &#125; &#125; 同时，倒带的请求没有AES加密，而网易云都有AES加密，所以在hookResponse方法内加上判断，如果是倒带的请求则不采用AES加解密，代码如下： 1234567891011121314151617super.hookResponse(response); byte[] bytes = response.getContent(); Log.d(&quot;ResponseSong:&quot;,new String(bytes)); if (!isRewind) &#123; bytes = Crypto.aesDecrypt(bytes); &#125; JSONObject jsonObject = JSONObject.parseObject(new String(bytes)); handleNoFreeSong(jsonObject); bytes = JSONObject.toJSONString(jsonObject, SerializerFeature.WriteMapNullValue).getBytes(); if(!isRewind) &#123; bytes = Crypto.aesEncrypt(bytes); &#125; Log.d(&quot;ResponseSong hooked:&quot;,new String(bytes)); response.setContent(bytes);&#125; 其中的isRewind是在BaseHook.java添加的布尔值变量。 还有一个小问题，倒带的请求结果JSON与网易云的也有区别，比如data数组里请求码套在了外面，所以还要在handleNoFreeSong方法里加上判断，代码跟上面判断差不多，就不放了。 看下效果： 添加通知栏快捷设置&emsp;&emsp;这个应该比上面的简单一点。新建类QuickTileService继承自TileService。由于Service内不能直接创建新VPN，所以要先判断是否已经创建过，代码如下： 123456789101112131415161718192021222324252627282930public void onClick() &#123; super.onClick(); Tile tile = getQsTile(); int State = tile.getState(); if(State == Tile.STATE_INACTIVE) &#123; Intent vpnIntent = VpnService.prepare(this); if (vpnIntent != null) &#123; Intent intent = new Intent(this, MainActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); Toast.makeText(this,&quot;请先在软件内开启一次VPN！&quot;,Toast.LENGTH_LONG).show(); return; &#125; else &#123; Intent intent = new Intent(this, LocalVPNService.class); startService(intent); &#125; tile.setState(Tile.STATE_ACTIVE); &#125; else &#123; Intent intent = new Intent(&quot;activity&quot;); intent.putExtra(&quot;cmd&quot;, &quot;stop&quot;); LocalBroadcastManager.getInstance(this).sendBroadcast(intent); Log.d(&quot;stopVPN&quot;); &#125;&#125; 然后在AndroidManifest.xml里面添加服务，代码如下： 12345678910&lt;service android:name=&quot;.utils.QuickTileService&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_netease_cloud_music&quot; android:permission=&quot;android.permission.BIND_QUICK_SETTINGS_TILE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.service.quicksettings.action.QS_TILE&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.service.quicksettings.ACTIVE_TILE&quot; android:value=&quot;true&quot;/&gt;&lt;/service&gt; 编译运行看一下效果：效果还不错，然后就可以正式打包成APK文件了。 结尾写这篇文章加上写代码总共花了大半天时间吧，更改后的代码我会放在GitHub，并且尝试合并到原作者的项目。 下载地址：点这里安装不上的请先卸载旧版本已知Bug：部分情况下网易云会无法播放歌曲，清除缓存即可还是用原版吧。 都看到这里了，还不去酷安给个三连支持一下？","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.revincx.icu/tags/%E7%BC%96%E7%A8%8B/"},{"name":"安卓","slug":"安卓","permalink":"https://blog.revincx.icu/tags/%E5%AE%89%E5%8D%93/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-09-15T04:52:48.000Z","updated":"2020-11-20T14:02:28.458Z","comments":true,"path":"posts/hello-world/","link":"","permalink":"https://blog.revincx.icu/posts/hello-world/","excerpt":"","text":"Q：这是什么东西？A：这是Hexo自动生成的测试文章，无视即可。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.revincx.icu/tags/Hexo/"}]}],"categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.revincx.icu/tags/Vue-js/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.revincx.icu/tags/%E7%AC%94%E8%AE%B0/"},{"name":"云储存","slug":"云储存","permalink":"https://blog.revincx.icu/tags/%E4%BA%91%E5%82%A8%E5%AD%98/"},{"name":"网站","slug":"网站","permalink":"https://blog.revincx.icu/tags/%E7%BD%91%E7%AB%99/"},{"name":"编程","slug":"编程","permalink":"https://blog.revincx.icu/tags/%E7%BC%96%E7%A8%8B/"},{"name":"网页设计","slug":"网页设计","permalink":"https://blog.revincx.icu/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"},{"name":"教程","slug":"教程","permalink":"https://blog.revincx.icu/tags/%E6%95%99%E7%A8%8B/"},{"name":"网络安全","slug":"网络安全","permalink":"https://blog.revincx.icu/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.revincx.icu/tags/Hexo/"},{"name":"安卓","slug":"安卓","permalink":"https://blog.revincx.icu/tags/%E5%AE%89%E5%8D%93/"}]}